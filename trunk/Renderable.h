/*! \file Renderable.h
 * Defines the Renderable abstract class, which provides a simple modular
 * interface to some of the GLUT callbacks. This file contains the requisite
 * definitions to use the class.
 *
 * \author Zachary Murray
 * \date Created on 11/15/09
 */

#ifndef NHZ_RENDERABLE_H
#define NHZ_RENDERABLE_H

class Renderable {
  public:
    virtual void render() const = 0;
    virtual void idle(const int elapsed);
    virtual void handleMouseEvent(int button, int state, int x, int y);
    virtual void handleMouseDrag(int x, int y);
    virtual void handleMouseMotion(int x, int y);
};

#endif

/*! \def NHZ_RENDERABLE_H
 * The define guard for Renderable.h. Define guards provide a cross-platform
 * method of preventing a header file from being included more than once.
 */

/*! \class Renderable
 * Provides a simple modular interface to some of the GLUT callbacks.
 * Essentially, this class delegates the responsibility of rendering, idling,
 * and handling common mouse events to subclasses of Renderable. That is, each
 * item to be rendered on screen overrides the relevant method of Renderable in
 * its subclass definition.
 *
 * When subclassing Renderable, one must override the Renderable::render()
 * method, as it is assumed that something is to be drawn, and also because the
 * method is a pure virtual method.
 *
 * The default implementation of Renderable's methods do nothing, although it is
 * wise in a subclass of Renderable to call the superclass method anyway, so
 * that if a future revision of the class changes the default behavior of the
 * methods, subclasses will automatically receive those changes.
 *
 * Renderable is intended to be used with the RenderQueue class, which is itself
 * a subclass of Renderable.
 * 
 * \sa RenderQueue
 * \headerfile Renderable.h
 */

/*! \fn virtual void render() const = 0
 * Abstract method that defines the process to render this object to the screen.
 * No processing should be done in the render method so that rendering takes as
 * little time as possible. Doing operations unrelated to rendering will slow
 * rendering performance considerably. Note that this is a constant method; this
 * is to prevent class field modification (and therefore, processing) while
 * rendering.
 *
 * All subclasses of Renderable must override this method. The definition for
 * this method can be thought of as a display callback specific to this object;
 * in other words, every subclass of Renderable has their own display callback.
 *
 * The default implementation of this method does nothing.
 * 
 * \memberof Renderable
 */

/*! \fn virtual void idle(const int elapsed)
 * Called while the application is idling (i.e., not rendering). This function
 * is where all of the object's processing should take place in order to prevent
 * interfering with the render times.
 *
 * The default implementation of this method does nothing.
 *
 * \param elapsed The number of elapsed milliseconds since the last idle.
 * \memberof Renderable
 */

/*! \fn virtual void handleMouseEvent(int button, int state, int x, int y)
 * Called when a mouse event occurs. The default implementation ignores the
 * event. If the event should interact with a subclass of Renderable, then that
 * implementation should override this method.
 *
 * \param button An integer representing which mouse button was clicked. Refer
 * to the GLUT documentation for more information about the possible values for
 * this parameter.
 * \param state A boolean integer that provides information about the up/down
 * state of the mouse button for this event. For more information about this
 * parameter, refer to the GLUT documentation.
 * \param x The x value of the site of the mouse event in screen coordinates.
 * \param y The y value of the site of the mouse event in screen coordinates.
 * \memberof Renderable
 */

/*! \fn virtual void handleMouseDrag(int x, int y)
 * Called while the mouse is being dragged. Multiple messages will be processed
 * while the mouse is being dragged, and, as a result, this function will be
 * called many times. The default implementation of this method ignores all of
 * these events.
 *
 * \param x The x value of the site of the mouse event in screen coordinates.
 * \param y The y value of the site of the mouse event in screen coordinates.
 * \memberof Renderable
 */

/*! \fn virtual void handleMouseMotion(int x, int y)
 * Like handleMouseDrag, except this method is called while the mouse moves over
 * the screen (instead of only while a drag event is occurring). Multiple
 * messages are generated by this event, and if a lot of processing takes place
 * in this method, considerable slowdown should be expected.
 *
 * The default implementation of this method does nothing.
 *
 * \param x The x value of the site of the mouse event in screen coordinates.
 * \param y The y value of the site of the mouse event in screen coordinates.
 * \memberof Renderable
 */
